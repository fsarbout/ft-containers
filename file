# QUESTIONS.md

## 1 -  why do we need iterators ?

* easy to work with , I can use iterator for a container without knowing the structure of container.
* iterators reduce the complexity and execution time of program.
* facilitate accessing, editing and  performing operators on container elements
* they connect the algorithm with the container.
* work with different containers, need to add operator overload if logic is different
* STL is based on the separation of data and operations , iterators are the bridge between them.

## 2 -  what is iterator traits ?

* class provides information about iterator so that the algorithm can know which methods it has to apply on that    container.
* we use it in reverse_iterator, reverse_iterator works only with bidirectional and random access iterators, and it has to ensure that it one of them.



# what is iterator category ?

# what is iterator category tag ?

* empty class, it is just a name that defines is ${iterator_category}_tag.
* to know how we could deal with the iterator, (if it should provide only methods for input iterator for example it has to be input_iterator_tag, helps also with algorithms)

# what is reverse iterator ? why do we need it ? we can easily use begin() instead of rend()?


* 

# returning this vs *this vs this.ptr ...
# why do we need const_iterator and iterator ?
# why do we need const ??
# what is std::pair , std::make_pair ?
# what is equal ?
# what is lexicographical_compare ?
# when do we need const ?
# what is typedef ? typename ? template templaet ? type template ?...
# what is enum ?
# what did I did in every vector method and what is the behavior of every single one?
# how could that we are using random iterator and defining vector constructor with a type of InputIterator ? 
# what is explicit ?
# why do we declare template fucntions inside template class ?
# what is template template parameter ?
# <>::<> syntax ?
# allocator methods and how are they working ?
# destroy ?
# the fucking address and references ???!!!
# test with debugger and check values .
# pragme once &&  pre processing 

# rvalues and lvalues ?
* 

# typedef typename ?
typename : telling the compiler that the template parameter is a type.
typedef : define an existing type with a new name.
typedef typename _Mybase::value_type value_type;
^^ telling the compiler that _Mybase::value_type is a type and not a variable. so that 
the typedef can rely on that fact
